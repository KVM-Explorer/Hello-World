
# <center>最小生成树</center>

#### 摘要

​		本文主要阐述了什么是最小生成树问题，它产生的缘由和对日常生活的影响，相关求解问题算法的发展历程。并对部分算法在时间复杂度等方面进行比较说明，并以其中两种常用的算法，Prim算法和Kruskal算法进行重点的讲解以及如何通过编程(C++)实现。

#### 关键字：

​		最小生成树、无向图、算法、赋权、Prim、Kruskal、代码、C++

## 1 最小生成树问题

​		在一给定的无向图G = <V, E,W> 中，(u, v) 代表连接结点 u 与结点 v 的边，而 w(u, v) 代表此边的权重，若存在 T^*^ 为 G 的生成子图且无闭合回路，使得的 W(T^*^) 最小，则此 T^*^ 为 G 的最小权重生成树(简称为最小生成树)。^[3]^
$$
W(T^*)=\sum _{(u,v)\in E}  w(u,v)
$$
。 

## 2 问题的产生和影响

​		在生活中，不同城市间电网的架设、解决矿井通风管道、城市间修路等问题需要一种具有普遍意义的解决方法。即如何使不同的点直接或间接相连且使总连接费用最小，进而催生出了最小生成树问题。解决这类问题，对于节约工程耗材、确定预算等具有重要意义。

## 3 问题解决方法的发展^[1]^

###### 3.1 Borůvka的算法

​		捷克科学家Otakar Borůvka在1926年开发了第一种寻找最小生成树的算法。它的目的是使电网有效地覆盖莫拉维亚。该算法按一系列阶段进行。在每个阶段，称为*Boruvka step*，它表示森林*F*由连接到图中每个结点的最小权值边组成*G*，然后形成图形$G_1=G/F$作为输入进入下一步。这里$G/F$表示由*G*通过收缩边*F* (通过切割性质，这些边属于最小生成树）。每一步都需要线性时间。由于每一步顶点的数量至少减少一半，所以boruvka的算法时间复杂度为O($mlogn)$。

###### 3.2 Prim算法

​		Prim算法由Jarnik在1930年发明，Prim在1957年和Dijkstra在1959年重新发现。它每次只增加一条边来构造最小生成树。最初，T包含一个任意顶点。在每一步中，T都用最小权值边$(x,y)$进行扩增，使x在T中，y还没有在T中。根据割的性质，添加到T中的所有边都在所求的最小生成树中。它的运行时要么是O($m log n$)要么是O($m+n log n$)，这取决于所使用的数据结构。

###### 3.3 Kruskal算法

​		该算法由Joseph Kruskal在1956年发表的kruskal的算法，它也需要O($m\,log n$)时间。先构造一个只含 n 个顶点而边集为空的子图，把子图中各个顶点看成各棵树上的根结点，之后，从图的边集 E 中选取一条权值最小的边，若该条边的两个顶点分属不同的树，则将其加入子图，即把两棵树合成一棵树。反之，若该条边的两个顶点已落在同一棵树上，则不可取，而应该取下一条权值最小的边再试之。以此类推，直到森林中只有一棵树，也即子图中含有 n-1 条边为止。

###### 3.4 反向删除算法

​		它由Kruskal(1956)发布Kruskal算法论文时首次提出，但是两者不能混淆。对于一个非连通图，该算法将为每个连通分支分别计算他们的最小生成树。这些最小生成树的集合，称之为最小生成树森林。它是通过对原始图进行删除边来来求解最小生成树。可以认为它是kruskal算法的反向。它的运行时是o($m\,log n(log log n)^3$)。

###### 3.5 Karger, Klein & Tarjan算法

​		Karger, Klein & Tarjan(1995)在一个比较模型中，边权值上唯一允许的操作是成对比较，发现了一个基于Borůvka算法和反向删除算法组合的线性时间随机算法。

###### 3.6 Bernard Chazelle算法

​		由Bernard Chazelle(2000)基于软堆设计的非随机比较算法是目前渐进最快的最小生成树算法。这是一个近似的优先队列，其运行时间为$o(m\  \alpha(m,n))$，其中α为阿克曼函数的经典泛函逆。函数α的生长极其缓慢，因此实际上它可以被认为是一个不大于4的常数；因此，chazelle的算法可以近似的认为是线性时间。

###### 3.7 小结

​		前四种算法都是贪心的算法。因为它们的时间复杂度为多项式时间，所以可以在FP时间内解决最小生成树问题。相关的决策问题，如确定某条边是否在最小生成树中，或确定最小总权重是否超过某一值，都可以在P时间内解决。



## 4 具体实现^[2]^

​		这里着重介绍两种常见的最小生成树算法Prim算法和kruskal算法以及相关的实现流程。

#### 4.1 Kruskal算法

###### 4.1.1 示例

<img src="C:\Users\KVM\Desktop\28091.png" style="zoom:100%;" />

###### 4.1.2 步骤

1. 对所有赋权边按边权大小进行排序。

2. 从边集中取出最小边权的边，计算该边连接的两点是否出于相同的图中。

   1. 如果处于相同的图，将该边从边集中删除。
   2. 如果处于不同的图，将该边删除后，将该边连接的不同的图进行合并
  
 3. 重复第二步直到完成最小生成树的构建。


###### 4.1.3 代码实现

```C++

struct ff
{
	int u,v,dis;
}e[200000+7];
int n,m;
int MST=0;
int fa[5000+7];
int cmp(ff a,ff b)
{
	if(a.dis<b.dis)return 1;
	return 0;
}
int find(int x)
{
	if(x==fa[x])return fa[x];
	else return fa[x]=find(fa[x]);
}

int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)	fa[i]=i;
	for(int i=1;i<=m;i++){
		scanf("%d%d%d",&e[i].u,&e[i].v,&e[i].dis);
	}
	sort(e+1,e+1+m,cmp);
	for(int i=1;i<=m;i++){
		int x1=find(e[i].u);
		int x2=find(e[i].v);
		if(x1!=x2){
			fa[x2]=x1;
			MST+=e[i].dis;
		}
	}
	printf("%d",MST);
}
		
		
```



#### 4.2 Prim算法简述

###### 4.2.1 示例

![28090](C:\Users\KVM\Desktop\28090.png)

###### 4.2.2 步骤

1. 初始化所有点到最小生成树的最小边权为$\infty$
2. 任意选取一个点作为根结点，构建一个图T^*^，并更新该点的最小边权为0。
3. 遍历与根节点相邻的结点更新他们到达最小生成树的最小边权。
4. 遍历所有未参与构建最小生成树的点，选择到最小生成树边权最小的点加入最小生成树。
5. 更新新加入最小生成树的相邻节点到最小生成树的距离。
6. 重复4、5直到最小生成树构建完成。

###### 4.2.3 代码实现

```c++

int n,m,MST;
int g[5007][5007];
int minn[5007];
int vis[5007];
int main()
{
	scanf("%d%d",&n,&m);
	memset(g,0x7f,sizeof(g));
	for(int i=1;i<=m;i++){
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		g[x][y]=g[y][x]=min(g[x][y],z);
	}
	memset(minn,0x7f,sizeof(minn));
	minn[1]=0;
	for(int i=1;i<=n;i++){
		int v=0;
		for(int j=1;j<=n;j++){
			if(!vis[j]&&minn[j]<minn[v])v=j;
		}
		vis[v]=1;
		if(v==0)break;
		MST+=minn[v];
		for(int j=1;j<=n;j++){
			if(!vis[j]&&g[v][j]<minn[j])minn[j]=g[v][j];
		}
	}
	printf("%d",MST);
	return 0;
}
```



## 参考文献

[1]:https://encyclopedia.thefreedictionary.com/Minimum+spanning+tree Minimum spanning tree

[2]:信息学奥赛一本通 科学技术文献出版社

[3]:https://baike.baidu.com/item/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/5223845?fr=aladdin 百度百科——最小生成树





